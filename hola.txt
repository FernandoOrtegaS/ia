from mcp.server.fastmcp import FastMCP
from pathlib import Path
from dotenv import load_dotenv
from pymongo import MongoClient
import os
import httpx
import psycopg
from psycopg.rows import dict_row

mcp = FastMCP()
@mcp.tool()
def saludar(nombre: str) -> str:
    """
    Devuelve un saludo personalizado.

    ParÃ¡metros:
    - nombre: nombre de la persona a saludar

    Retorna:
    - Un saludo en texto
    """
    return f"Hola, {nombre}! Â¿CÃ³mo estÃ¡s hoy?"

@mcp.tool()
def sumar(a: int, b: int) -> int:
    """Suma dos nÃºmeros enteros.""" # esto le sirve al llm para saber cuando hacerlo
    return a + b

@mcp.tool() #el path es para trabajar con archivos
def analizar_archivos(archivo: Path) -> dict:
    """Analiza un archivo y devuelve estadÃ­sticas."""
    path = Path(archivo)
    if not path.exists():
        raise FileNotFoundError(f"El archivo {path} no existe.")

    return {
        "nombre": path.name,
        "tamaÃ±o": path.stat().st_size,
        "tipo": path.suffix,
        "Ãºltimo_modificado": path.stat().st_mtime
    }

@mcp.tool()
async def buscar_repos(query: str) -> list[dict]:
    """Busca repositorios en GitHub."""
    url = f"https://api.github.com/search/repositories?q={query}"
    
    async with httpx.AsyncClient() as client:
        response = await client.get(url, headers={"Accept": "application/vnd.github.v3+json"})
        response.raise_for_status()
    
    return [{
        'name': repo['name'],
        'html_url': repo['html_url'],
        'url': repo['html_url']
    } for repo in response.json()['items']]

load_dotenv()
MONGODB_URI = os.getenv("MONGODB_URI")

@mcp.tool()
def consultar_mongodb1(accion: str, base: str, coleccion: str = None, documento: dict = None, filtro: dict = None) -> dict:
    """
    Ejecuta acciones sobre MongoDB Atlas:
    - "crear_coleccion"      â†’ Crea una nueva colecciÃ³n
    - "insertar_documento"   â†’ Inserta un documento en una colecciÃ³n
    - "eliminar_documento"   â†’ Elimina un documento de una colecciÃ³n
    - "listar_colecciones"   â†’ Lista las colecciones de una base
    - "buscar_documentos"    â†’ Busca documentos con un filtro opcional
    """
    if not MONGODB_URI:
        return {"error": "MONGODB_URI no estÃ¡ definido en el archivo .env"}

    client = MongoClient(MONGODB_URI)
    db = client[base]

    try:
        if accion == "crear_coleccion":
            db.create_collection(coleccion)
            return {"ok": True, "accion": "crear_coleccion", "coleccion": coleccion}

        elif accion == "insertar_documento":
            if not coleccion or not documento:
                return {"error": "Se requieren 'coleccion' y 'documento' para insertar."}
            res = db[coleccion].insert_one(documento)
            return {"ok": True, "inserted_id": str(res.inserted_id)}

        elif accion == "eliminar_documento":
            if not coleccion or not filtro:
                return {"error": "Se requieren 'coleccion' y 'filtro' para eliminar."}
            res = db[coleccion].delete_one(filtro)
            return {"ok": True, "deleted_count": res.deleted_count}

        elif accion == "listar_colecciones":
            return {"colecciones": db.list_collection_names()}

        elif accion == "buscar_documentos":
            if not coleccion:
                return {"error": "Se requiere el parÃ¡metro 'coleccion' para buscar documentos."}
            resultados = list(db[coleccion].find(filtro or {}).limit(20))
            for doc in resultados:
                doc["_id"] = str(doc["_id"])
            return {"resultados": resultados}

        else:
            return {"error": f"AcciÃ³n no reconocida: {accion}"}

    except Exception as e:
        return {"error": f"{type(e).__name__}: {str(e)}"}
    


DATABASE_URL = os.getenv("DATABASE_URL")
@mcp.tool()
def pg_query(sql_text: str, params: dict | None = None, limit: int = 100) -> dict:
    """
    Ejecuta una consulta SELECT segura contra PostgreSQL usando DATABASE_URL del .env.
    - Solo permite sentencias que comiencen con 'SELECT'.
    - Aplica LIMIT automÃ¡tico si no estÃ¡ presente.
    - 'params' permite parÃ¡metros nombrados (ej: %(e)s).

    Ejemplos:
      {"sql_text": "SELECT * FROM public.clientes WHERE email = %(e)s", "params": {"e":"ana@example.com"}}
      {"sql_text": "SELECT id, nombre FROM public.clientes ORDER BY id", "limit": 50}
    """
    if not DATABASE_URL:
        return {"ok": False, "error": "DATABASE_URL no estÃ¡ definida en .env"}

    if not sql_text or not sql_text.strip().lower().startswith("select"):
        return {"ok": False, "error": "Solo se permiten consultas SELECT"}

    # agrega LIMIT si no existe uno explÃ­cito
    add_limit = " limit " not in sql_text.strip().lower()
    query = sql_text + (f" LIMIT {int(limit)}" if add_limit else "")

    try:
        with psycopg.connect(DATABASE_URL, row_factory=dict_row) as conn:
            with conn.cursor() as cur:
                cur.execute(query, params or {})
                rows = cur.fetchall()
        return {"ok": True, "rows": rows, "meta": {"applied_limit": add_limit, "limit": limit}}
    except Exception as e:
        return {"ok": False, "error": f"{type(e).__name__}: {e}"}

if __name__ == "__main__":
    mcp.run()







       Contexto de la base de datos

    La base de datos contiene **tablas dimensionales (prefijo `dim_`)** que sirven para almacenar entidades descriptivas, mÃ©tricas y catÃ¡logos usados en reportes y anÃ¡lisis.  
A continuaciÃ³n, se describen las principales categorÃ­as:

ESQUEMA "dbo"

### 1. MÃ©tricas agregadas
- **dim_aggregatebotmetrics** â†’ MÃ©tricas agregadas de interacciones con bots.  
- **dim_aggregatecampaignmetrics** â†’ MÃ©tricas de campaÃ±as (ej. llamadas o mensajes salientes).  
- **dim_aggregatedayqueuemetrics** â†’ MÃ©tricas de colas de atenciÃ³n por dÃ­a.  
- **dim_aggregateflowmetrics** â†’ MÃ©tricas de flujos (ej. IVR o flujos de conversaciÃ³n).  
- **dim_aggregatequeueagentmetrics** â†’ MÃ©tricas de agentes en colas de atenciÃ³n.  
- **dim_aggregatequeuemetrics** â†’ MÃ©tricas generales de colas.  
- **dim_aggregatetranscriptsmetrics** â†’ MÃ©tricas relacionadas con transcripciones.  
- **dim_aggregateusermetrics** â†’ MÃ©tricas globales por usuario.  
- **dim_aggregateuserpresencemetrics** â†’ MÃ©tricas de presencia (disponible, ausente, etc.).  
- **dim_aggregatewrapupcodemetrics** â†’ MÃ©tricas por cÃ³digos de cierre (wrap-up codes).  
- **dim_billingusagemetrics** â†’ MÃ©tricas de facturaciÃ³n y uso.  
- **dim_trunkmetrics** â†’ MÃ©tricas relacionadas con troncales de comunicaciÃ³n.

### 2. Conversaciones y evaluaciones
- **dim_conversation** â†’ Conversaciones individuales.  
- **dim_conversationdivisions** â†’ DivisiÃ³n de conversaciones por Ã¡rea o segmento.  
- **dim_conversationevaluations** â†’ Evaluaciones de calidad de conversaciones.  
- **dim_conversationevaluationsquestionsgroupscores** â†’ Puntuaciones por grupos de preguntas en evaluaciones.  
- **dim_conversationevaluationsquestionsscores** â†’ Puntuaciones por pregunta en evaluaciones.  
- **dim_dataparticipant** â†’ Participantes en una conversaciÃ³n.  
- **dim_edge** y **dim_edgemetrics** â†’ Dispositivos/redes (edge servers) y sus mÃ©tricas.  

### 3. Evaluaciones de calidad
- **dim_evaluationform** â†’ Formularios de evaluaciÃ³n.  
- **dim_evaluationquestion** â†’ Preguntas de evaluaciÃ³n.  
- **dim_evaluationquestiongroups** â†’ Grupos de preguntas.  
- **dim_evaluationquestionoptions** â†’ Opciones de respuesta.  

### 4. Flujos y sesiones
- **dim_flow** â†’ Flujos de interacciÃ³n (ej. IVR).  
- **dim_flowmilestone** â†’ Hitos dentro de un flujo.  
- **dim_flowoutcome** â†’ Resultados de un flujo.  
- **dim_session** â†’ Sesiones de usuario.  
- **dim_sessionflow** â†’ RelaciÃ³n entre sesiones y flujos.  
- **dim_sessionflowoutcomes** â†’ Resultados alcanzados en sesiones/flujo.  
- **dim_sessionmetrics** â†’ MÃ©tricas de sesiones.  
- **dim_segment**, **dim_segmenttype** â†’ Segmentos de conversaciÃ³n y tipos de segmento.  

### 5. OrganizaciÃ³n y estructura
- **dim_campaign** â†’ CampaÃ±as.  
- **dim_contactlist** â†’ Listas de contactos.  
- **dim_department** â†’ Departamentos.  
- **dim_division** â†’ Divisiones organizacionales.  
- **dim_organization** â†’ OrganizaciÃ³n principal.  
- **dim_queue** â†’ Colas de enrutamiento.  
- **dim_skill** â†’ Habilidades asignables a agentes.  
- **dim_seg_requestedroutingskillids** â†’ Habilidades solicitadas para enrutamiento.  

### 6. Estados y presencias
- **dim_disconnecttype** â†’ Tipos de desconexiÃ³n.  
- **dim_originatingdirection** â†’ DirecciÃ³n de origen (entrante, saliente).  
- **dim_participant** â†’ Participantes en general (puede incluir agentes, clientes, bots).  
- **dim_presencestatus** â†’ Estados de presencia de usuario (disponible, ausente, en llamada).  
- **dim_typepresencestatus** â†’ Tipos de estados de presencia.  
- **dim_userstatusdetails** â†’ Detalles del estado de usuario.  

### 7. Tiempo y medios
- **dim_hour** â†’ DimensiÃ³n de horas del dÃ­a.  
- **dim_time** â†’ DimensiÃ³n de tiempo general (fecha, semana, mes, aÃ±o).  
- **dim_mediatype** â†’ Tipos de medio (voz, chat, email, redes sociales).  
- **dim_trunk** â†’ Troncales de comunicaciÃ³n (telefonÃ­a).  

### 8. Usuarios y wrap-up
- **dim_user** â†’ Usuarios o agentes.  
- **dim_wrapup** â†’ CÃ³digos de wrap-up (motivos de cierre).  

---

ðŸ‘‰ Este contexto permite a un modelo LLM entender para quÃ© sirve cada tabla y cÃ³mo se relacionan.  
Las **tablas `dim_*` son dimensiones y mÃ©tricas** que se cruzan con tablas de hechos en reportes de interacciones, usuarios, colas, sesiones y evaluaciones de calidad.